# rides-minimal

## Цели

- [ ] Переносим сюда оставшийся код из [ноутбука rides2.ipynb на Google Colab](https://colab.research.google.com/drive/1DXsJBTyVvAXrU1aEy5GFWiF_i75LmWS1#scrollTo=h3WG4Nex_pmC)
- [ ] Пишем тесты на основе еще более короткого датасета, чем [one_day.zip](one_day.zip)
- [ ] Генерируем документацию (sphinx или mkdocs-react)
- [ ] Вывешиваем минимальный пример использования пакета на Colab (замечание - у нас частный репозитарий, напрямую сложно)
- [ ] Составляем план/roadmap доработок (вставки из "тяжелого" алгоритма и т.д.)

Сделано:
- [x] Переносим сюда анализ датасета [one_day.zip](one_day.zip)


## Текущие задачи (предложения)

- [ ] code review файла [search.py](search.py)
- [ ] сформировать данные для минимальныого примера данных - три трека, так чтобы было: одна пара - высокое сближение, другая пара - среднее сближение, третья пара - нет сближения.

## Псеводкод обработки данных

Вне репо:

- Мы прочли сырые данные из JSON, получили одну таблицу данных

В этом репо:

- Получили исходные данные `one_day.zip`
- Преобразовали исходные данные в список треков `[Trip]: [поездка:(id_машины, дата), трек:(широта, долгота, метка времени)]`
- Составляем все возможные комбинации треков, количество таких пар будет равно `n * (n-1) / 2`
- Проводим анализ фигур треков в два этапа:
 - выбраковываем непересекающиеся треки (в грубой апроксимации треков)
 - оцениваем близость фигур оставшихся пар треков треков (в более точной апрокимации треков)
- Внутри каждой пары треков получаем два коэффициента перекрытия треков (первого трека вторым, второго трека первым)
- Сделали выгрузку итоговых результатов (`output.csv` - должен совпадать с top 20 в ноутбуке)

После этого репо:

- Анализируем все попарные характеристики, получаем сводные результаты на уровне всей выборки

## Упрощения

- смотрим путь машины внутри суток без учета разных заказов (объединяем заказы в один в течение суток)

<!--

Ключевые слова: Hausdorff distance, Fréchet distance (расстояния между кривыми).

Замысел:

- перетащить сюда код, который мы сделали для "легкой" модели анализа треков
- урезать тестовый датасет до 1 дня - можно писать юнит и end-to-end тесты 
- попутно отрефакторирить код из ноутбука
- документация (sphinx, mkdocs-react)
- привлечь новых коллег к работе над частями кода (отдельные issues)

Выигрыши:

- в ноутбуке будет меньше кода, больше к демонстрации результатов
- можем заняться задачей сближения "тяжелой" и "легкой" модели
- "продуктизация" нашей разработки
- `pip install что-то`
- в целом, лучше подготовимся к последующим работам / развитию проекта

Минусы:

- формально нам не заказывали это сделать, работа подготовительная,
  хотя мы и анонсировали ее
- workflow - не запутаться, кто что делает + это не ноутбук (git + Travis CI)
- у нас не все части в ноутбуке стабильные и полные, надо понимать что там происходит,
  что-то достраивать
  
-->
